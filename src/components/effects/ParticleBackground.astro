---
// ParticleBackground Component
// Creates an interactive particle animation background that responds to mouse and scroll
// Uses tsParticles bundle from CDN (simpler API like auxo-landing-page)
---

<div
  id="particle-background"
  class="fixed inset-0 pointer-events-none"
  aria-hidden="true"
>
</div>

<script>
  // Type declaration for tsParticles loaded from CDN
  declare global {
    interface Window {
      tsParticles?: {
        load: (id: string, config: unknown) => Promise<void>;
      };
    }
  }

  // Store cleanup functions
  let scrollHandler: (() => void) | null = null;
  let mouseMoveHandler: ((e: MouseEvent) => void) | null = null;
  let scrollTimeout: ReturnType<typeof setTimeout> | null = null;

  // Cleanup function
  function cleanup() {
    // Cleanup particles
    try {
      // Clear container
      const container = document.getElementById("particle-background");
      if (container) {
        container.innerHTML = ""; // Clear canvas
      }
    } catch (e) {
      // Ignore errors if particles not initialized
    }

    // Remove event listeners
    if (scrollHandler) {
      window.removeEventListener("scroll", scrollHandler);
      scrollHandler = null;
    }
    if (mouseMoveHandler) {
      window.removeEventListener("mousemove", mouseMoveHandler);
      mouseMoveHandler = null;
    }

    // Clear timeout
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
      scrollTimeout = null;
    }

    // Remove cursor effect
    const cursorEffect = document.querySelector(".cursor-effect");
    if (cursorEffect) {
      cursorEffect.remove();
    }
  }

  // Initialize particles on page load
  async function initParticles() {
    // Wait for DOM to be ready
    if (typeof window === "undefined") return;

    const container = document.getElementById("particle-background");
    if (!container) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) {
      return; // Skip particles if user prefers reduced motion
    }

    // Wait for tsParticles to be loaded from CDN
    let attempts = 0;
    const maxAttempts = 50; // Wait up to 5 seconds for CDN to load
    while (
      typeof window.tsParticles === "undefined" &&
      attempts < maxAttempts
    ) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      attempts++;
    }

    if (typeof window.tsParticles === "undefined") {
      console.error("tsParticles not loaded from CDN");
      return;
    }

    // Detect device type for performance optimization
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    const isTablet = window.matchMedia(
      "(max-width: 1024px) and (min-width: 769px)",
    ).matches;

    // Generate random configuration for unique experience on each load
    let randomParticleCount: number;
    let randomSpeed: number;
    let randomLinkDistance: number;
    let randomConnectDistance: number;
    let randomAnimSpeed: number;
    let randomShapeType: string[];

    if (isMobile) {
      randomParticleCount = Math.floor(Math.random() * 15) + 20; // 20-35 particles
      randomSpeed = Math.random() * 0.4 + 0.3; // 0.3-0.7 (increased from 0.2-0.5)
      randomLinkDistance = Math.floor(Math.random() * 50) + 80; // 80-130px
      randomConnectDistance = Math.floor(Math.random() * 50) + 80; // 80-130px
    } else if (isTablet) {
      randomParticleCount = Math.floor(Math.random() * 25) + 35; // 35-60 particles
      randomSpeed = Math.random() * 0.5 + 0.35; // 0.35-0.85 (increased from 0.25-0.65)
      randomLinkDistance = Math.floor(Math.random() * 70) + 90; // 90-160px
      randomConnectDistance = Math.floor(Math.random() * 70) + 100; // 100-170px
    } else {
      randomParticleCount = Math.floor(Math.random() * 40) + 50; // 50-90 particles
      randomSpeed = Math.random() * 0.7 + 0.4; // 0.4-1.1 (increased from 0.3-0.9)
      randomLinkDistance = Math.floor(Math.random() * 100) + 100; // 100-200px
      randomConnectDistance = Math.floor(Math.random() * 100) + 120; // 120-220px
    }

    const randomDirection = [
      "right",
      "left",
      "top",
      "bottom",
      "top-right",
      "top-left",
      "bottom-right",
      "bottom-left",
    ][Math.floor(Math.random() * 8)];

    // Get theme-aware opacity values from CSS variables
    const getComputedOpacity = (varName: string, fallback: number): number => {
      const value = getComputedStyle(document.documentElement)
        .getPropertyValue(varName)
        .trim();
      return value ? parseFloat(value) : fallback;
    };

    const particleOpacityMin = getComputedOpacity(
      "--particle-opacity-min",
      0.15,
    );
    const particleOpacityMax = getComputedOpacity(
      "--particle-opacity-max",
      0.35,
    );
    const particleLinkOpacity = getComputedOpacity(
      "--particle-link-opacity",
      0.2,
    );
    const particleTriangleOpacity = getComputedOpacity(
      "--particle-triangle-opacity",
      0.08,
    );
    const particleCursorOpacity = getComputedOpacity(
      "--particle-cursor-opacity",
      0.12,
    );

    // Use theme-aware opacity for links
    randomAnimSpeed = Math.random() * 3 + 1; // 1-4 (increased from 0.5-2.5 for more dynamic animation)
    randomShapeType =
      Math.random() > 0.5
        ? ["circle", "square"]
        : Math.random() > 0.5
          ? ["circle", "triangle"]
          : ["circle"];

    // Initialize tsParticles with enhanced interactivity (using bundle API)
    try {
      // Use the simpler bundle API like auxo-landing-page
      await window.tsParticles.load("particle-background", {
        fpsLimit: isMobile ? 30 : 60,
        interactivity: {
          events: {
            onHover: {
              enable: !isMobile,
              mode: "connect",
            },
            resize: true,
          },
          modes: {
            connect: {
              distance: randomConnectDistance,
              links: {
                opacity: 0.5,
              },
              radius: randomConnectDistance + 80,
            },
          },
        },
        particles: {
          color: {
            value:
              getComputedStyle(document.documentElement)
                .getPropertyValue("--accent-green")
                .trim() || "#A3E635", // Theme-aware accent color
          },
          links: {
            color:
              getComputedStyle(document.documentElement)
                .getPropertyValue("--accent-green")
                .trim() || "#A3E635",
            distance: randomLinkDistance,
            enable: true,
            opacity: particleLinkOpacity,
            width: 1,
            triangles: {
              enable: true,
              opacity: particleTriangleOpacity,
            },
            frequency: 0.05, // Slightly more frequent connections (default is 0.01)
          },
          move: {
            direction: randomDirection,
            enable: true,
            outModes: {
              default: "bounce",
            },
            random: Math.random() > 0.3, // More random movement (changed from > 0.5 to > 0.3)
            speed: randomSpeed,
            straight: Math.random() > 0.5, // Less straight movement for more organic feel (changed from > 0.3 to > 0.5)
            attract: {
              enable: false, // Disable attract for cleaner movement
            },
            trail: {
              enable: false, // Keep trails off for readability
            },
          },
          number: {
            density: {
              enable: true,
              area: 1000,
            },
            value: randomParticleCount,
          },
          opacity: {
            value: { min: particleOpacityMin, max: particleOpacityMax },
            animation: {
              enable: true,
              speed: randomAnimSpeed * 1.2, // 20% faster opacity animation
              minimumValue: particleOpacityMin,
              sync: false,
            },
          },
          shape: {
            type: randomShapeType,
          },
          size: {
            value: { min: 1, max: 3 },
            animation: {
              enable: true,
              speed: randomAnimSpeed * 1.2, // 20% faster size animation
              minimumValue: 0.5,
              sync: false,
            },
          },
        },
        background: {
          color:
            getComputedStyle(document.documentElement)
              .getPropertyValue("--bg-primary")
              .trim() || "#000000", // Theme-aware background
        },
        detectRetina: true,
      });
    } catch (error) {
      console.error("Failed to load particles:", error);
    }

    // Add scroll-based effects
    let lastScrollY = window.scrollY;

    scrollHandler = () => {
      const currentScrollY = window.scrollY;
      const scrollVelocity = Math.abs(currentScrollY - lastScrollY);
      lastScrollY = currentScrollY;

      if (container) {
        // Visual effect: slightly fade particles when scrolling fast
        container.style.opacity = String(
          1 - Math.min(scrollVelocity * 0.02, 0.3),
        );
      }

      // Clear existing timeout
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Reset opacity after scrolling stops
      scrollTimeout = setTimeout(() => {
        if (container) {
          container.style.opacity = "1";
        }
      }, 50);
    };

    window.addEventListener("scroll", scrollHandler, { passive: true });

    // Enhanced mouse movement tracking
    let lastMouseX = 0;
    let lastMouseY = 0;

    mouseMoveHandler = (e: MouseEvent) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const deltaX = mouseX - lastMouseX;
      const deltaY = mouseY - lastMouseY;
      const mouseVelocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      // Update particle interaction based on mouse movement
      // tsParticles handles the actual particle interaction, we add visual feedback
      if (mouseVelocity > 5) {
        let cursorEffect = document.querySelector(
          ".cursor-effect",
        ) as HTMLElement;
        if (!cursorEffect) {
          cursorEffect = document.createElement("div");
          cursorEffect.className = "cursor-effect";
          const accentColor =
            getComputedStyle(document.documentElement)
              .getPropertyValue("--accent-green")
              .trim() || "#A3E635";
          const rgb = hexToRgb(accentColor);
          const cursorOpacity = particleCursorOpacity;
          cursorEffect.style.cssText = `
            position: fixed;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${cursorOpacity}) 0%, transparent 70%);
            pointer-events: none;
            z-index: -9;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease;
          `;
          document.body.appendChild(cursorEffect);
        }

        cursorEffect.style.left = `${mouseX}px`;
        cursorEffect.style.top = `${mouseY}px`;
        const maxOpacity = particleCursorOpacity * 4;
        cursorEffect.style.opacity = String(
          Math.min(mouseVelocity / 50, maxOpacity),
        );
      }

      lastMouseX = mouseX;
      lastMouseY = mouseY;
    };

    window.addEventListener("mousemove", mouseMoveHandler, { passive: true });
  }

  // Helper function to convert hex to RGB
  function hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 163, g: 230, b: 53 }; // Default to brand color
  }

  // Initialize when DOM is ready and tsParticles is loaded
  function waitForInit() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", waitForInit);
      return;
    }

    // Wait for tsParticles to be available
    if (typeof window.tsParticles !== "undefined") {
      initParticles();
    } else {
      // Retry after a short delay
      setTimeout(waitForInit, 100);
    }
  }

  // Start initialization
  waitForInit();

  // Reinitialize particles when theme changes
  const themeObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "class"
      ) {
        const html = document.documentElement;
        if (
          html.classList.contains("dark") ||
          html.classList.contains("light")
        ) {
          // Theme changed, reinitialize particles with new opacity values
          cleanup();
          setTimeout(() => {
            waitForInit();
          }, 100);
        }
      }
    });
  });

  // Observe theme changes on html element
  if (typeof document !== "undefined") {
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });
  }

  // Cleanup and reinitialize on Astro view transitions
  document.addEventListener("astro:before-swap", cleanup);
  document.addEventListener("astro:page-load", waitForInit);
</script>

<style>
  #particle-background {
    position: fixed;
    inset: 0;
    z-index: 0; /* Behind all content */
    pointer-events: none;
    background-color: transparent !important; /* Make container transparent to see particles */
  }

  /* Ensure navigation and interactive elements are above particles */
  nav {
    position: relative;
    z-index: 50;
  }

  main {
    position: relative;
    z-index: 10; /* Above particle background */
  }

  footer {
    position: relative;
    z-index: 10; /* Above particle background - same as main content */
    background-color: var(--bg-card); /* Theme-aware footer background */
  }

  /* Override tsParticles inline styles to ensure canvas is visible */
  #particle-background canvas {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 0 !important;
    background-color: transparent !important; /* Critical: transparent background to see particles */
    pointer-events: none !important;
  }
</style>
